class paramActor:
    def __init__(
        self,
        build_function,
        build_kwargs,
        reinitialize_before_sweep,
        reinitialize_function,
        reinitialize_kwargs,
        optimize_function,
        optimize_kwargs,
        probe_function,
        outputs,
        json_string,
        use_analysis_tools=None,
    ):
        self.build_function = build_function
        self.build_kwargs = build_kwargs
        self.reinitialize_before_sweep = reinitialize_before_sweep
        self.reinitialize_function = reinitialize_function
        self.reinitialize_kwargs = reinitialize_kwargs
        self.optimize_function = optimize_function
        self.optimize_kwargs = optimize_kwargs
        self.outputs = outputs
        self.probe_function = probe_function
        self.model_init = False
        self.model = None
        self.json_string = json_string
        self.build_model()
        try:
            from watertap.tools.analysis_tools.model_state_tool import modelStateStorage
            import watertap.tools.analysis_tools.step_optimize_tool as stepTool

            if use_analysis_tools == None:
                self.use_analysis_tools = True
            else:
                self.use_analysis_tools = use_analysis_tools
        except ImportError:
            self.use_analysis_tools = False

    def build_model(self):
        del self.model
        self.model = self.build_function(**self.build_kwargs)
        if self.json_string is not None:
            if self.use_analysis_tools:
                self.model.state_after_box_solve = modelStateStorage(
                    self.model, restore_dict=self.json_string
                )
            else:
                from_json(self.model, sd=None, fname=None, s=self.json_string)

            self.model_init = True

    def init_model(self):
        self.build_model()
        if self.reinitialize_function is not None:
            self.reinitialize_function(self.model, **self.reinitialize_kwargs)
            self.model_init = True

    def get_probe_result(self, m, sweep_params):
        if self.probe_function is None:
            return True
        else:
            try:
                probe_result = self.probe_function(m, sweep_params)
            except:
                print("----------------------------------")
                print("error in probe function!!!!!!!!!!!")
                probe_result = True
            return probe_result

    def step_optimize(
        self, m, solver=None, try_final_first=False, check_termination=False
    ):
        # fsTools.solve(m)
        solver = get_solver()
        results = stepTool.step_optimize(
            m,
            solver,
            self.optimize_function,
            self.model.state_after_box_solve,
            steps=3,
            try_final_first=True,
            re_steps=2,
        )
        return results

    def solve_problem(self, sweep_params):
        order_index = sweep_params["order_index"]
        sweep_params.pop("order_index", None)

        run_successful = False

        _update_model_values_from_dict(self.model, sweep_params)
        # results = self.step_optimize(self.model)
        if self.get_probe_result(self.model, self.reinitialize_kwargs):
            for i in ["Try #0", "Try #1"]:
                if self.reinitialize_function is not None and self.model_init == False:
                    try:
                        self.init_model()
                        self.model_init = True
                    except:
                        self.model_init = False
                        run_successful = False
                        init_okay = False

                _update_model_values_from_dict(self.model, sweep_params)

                if self.model_init and self.get_probe_result(
                    self.model, self.reinitialize_kwargs
                ):
                    try:
                        results = self.step_optimize(
                            self.model
                        )  # , **self.optimize_kwargs)
                        pyo.assert_optimal_termination(results)
                        run_successful = True
                        break
                    except:
                        run_successful = False
                        self.model_init = False
                        if (
                            self.reinitialize_before_sweep == False
                            and self.reinitialize_function is None
                        ):
                            break

                else:
                    print("Model failed to init, skipping condition!")
                    break
        output_dict = _create_local_output_skeleton(
            self.model, sweep_params, self.outputs, run_successful
        )
        output_dict["order_index"] = order_index
        print("RUN Complete, solution optimal: {}".format(run_successful))
        print(
            "Param {} \n Build option {} \n Init option {}".format(
                sweep_params, self.build_kwargs, self.reinitialize_kwargs
            )
        )
        return output_dict
