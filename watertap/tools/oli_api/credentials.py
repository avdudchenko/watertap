###############################################################################
# WaterTAP Copyright (c) 2020-2023, The Regents of the University of California,
# through Lawrence Berkeley National Laboratory, Oak Ridge National Laboratory,
# National Renewable Energy Laboratory, and National Energy Technology
# Laboratory (subject to receipt of any required approvals from the U.S. Dept.
# of Energy). All rights reserved.
#
# Please see the files COPYRIGHT.md and LICENSE.md for full copyright and license
# information, respectively. These files are also available online at the URL
# "https://github.com/watertap-org/watertap/"
#
# OLI Systems, Inc. Copyright Â© 2022, all rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# 3. Neither the name of OLI Systems, Inc. nor the names of any contributors to
# the software made available herein may be used to endorse or promote products derived
# from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
# SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# You are under no obligation whatsoever to provide any bug fixes, patches, or upgrades to the
# features, functionality or performance of the source code ("Enhancements") to anyone; however,
# if you choose to make your Enhancements available either publicly, or directly to OLI Systems, Inc.,
# without imposing a separate written license agreement for such Enhancements, then you hereby grant
# the following license: a non-exclusive, royalty-free perpetual license to install, use, modify, prepare
# derivative works, incorporate into other computer software, distribute, and sublicense such enhancements
# or derivative works thereof, in binary and source code form.
###############################################################################

__author__ = "Paul Vecchiarelli"

import json
import requests
from pathlib import Path
from os.path import join, exists

from pyomo.common.dependencies import attempt_import

cryptography, cryptography_available = attempt_import("cryptography", defer_check=False)
if cryptography_available:
    from cryptography.fernet import Fernet


class CredentialManager:
    """
    A class to handle credentials for OLI Cloud.
    """

    def __init__(
        self,
        username="",
        password="",
        root_url="",
        auth_url="",
        config_file="",
        encryption_key="",
        test=False,
    ):
        """
        Manages credentials for OLIApi authentication requests.

        :param username: user's username
        :param password: user's password
        :param root_url: root url
        :param auth_url: authorization url
        :param config_file: existing/desired path to encrypted oli_config_file
        :param encryption_key: fernet key generated by credential manager object
        :param test: bool switch for automation during tests
        """

        # TODO: add method to generate access key
        self.credentials = {
            "username": username,
            "password": password,
            "root_url": root_url,
            "auth_url": auth_url,
        }
        self.encryption_key = encryption_key
        self.test = test

        if self.test is False:
            if config_file == "":
                config_file = "credentials.txt"
            self.config_file = join(Path(__file__).parents[0], config_file)
        else:
            self.config_file = join(
                Path(__file__).parents[0], "tests", "test_credentials.txt"
            )

        if cryptography_available:
            self._manage_credentials()
        else:
            raise ModuleNotFoundError("Module 'cryptography' not available.")

        if self.test is False:
            self.login()

    def _manage_credentials(self):
        """
        Method to save/load OLI credentials.
        """

        if self.encryption_key == "":
            if "" in self.credentials.values():
                raise IOError(
                    f" Incomplete credentials provided:"
                    + " username, password, root_url, and auth_url required"
                    + " if encryption_key is not provided."
                )
            else:
                if self._write_permission() is True:
                    self.encryption_key = self._encrypt_credentials()
        else:
            if exists(self.config_file):
                self.credentials = self._decrypt_credentials()
            else:
                raise OSError(
                    f" Config file {self.config_file} does not exist."
                    + " Provide complete credentials to generate a file."
                )

        self.dbs_url = self.credentials["root_url"] + "/channel/dbs"
        self.upload_dbs_url = self.credentials["root_url"] + "/channel/upload/dbs"
        self.engine_url = self.credentials["root_url"] + "/engine/"
        self._delete_dbs_url = self.credentials["root_url"] + "/channel/file/"

    def _write_permission(self):
        """
        Ensures user permits deletion of specified files.

        :return boolean: status of user permission (to write encrypted config_file to disk)
        """

        if self.test is True:
            return True
        else:
            r = input(
                "WaterTAP will write encrypted file to store OLI Cloud credentials: [y]/n: "
            )
            if (r.lower() == "y") or (r == ""):
                return True
            return False

    def _encrypt_credentials(self):
        """
        Basic encryption method for credentials
        """

        encryption_key = Fernet.generate_key()

        if self.test is False:
            print(f"Your secret key is:\n{encryption_key.decode()}\nKeep it safe.\n")

        try:
            cipher = Fernet(encryption_key)
            encrypted_credentials = cipher.encrypt(
                json.dumps(self.credentials).encode()
            )
            with open(self.config_file, "wb") as f:
                f.write(encrypted_credentials)
            return encryption_key

        except:
            raise RuntimeError(f" Failed encryption.")

    def _decrypt_credentials(self):
        """
        Basic decryption method for credentials.

        :return credentials: login credentials for OLI Cloud
        """

        try:
            with open(self.config_file, "rb") as f:
                encrypted_credentials = f.read()

            cipher = Fernet(self.encryption_key)
            decrypted_credentials = cipher.decrypt(encrypted_credentials).decode()
            credentials = json.loads(decrypted_credentials)
            return credentials

        except:
            raise RuntimeError(" Failed decryption.")

    def login(self):
        """
        Login into user credentials for the OLI Cloud.

        :return boolean: True on success, False on failure
        """

        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        body = {
            "username": self.credentials["username"],
            "password": self.credentials["password"],
            "grant_type": "password",
            "client_id": "apiclient",
        }
        return self._get_req_status(headers, body)

    def get_refresh_token(self):
        """
        Uses refresh token to update access token.

        :return boolean: True on success, False on failure
        """

        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        body = {
            "refresh_token": self.refresh_token,
            "grant_type": "refresh_token",
            "client_id": "apiclient",
        }
        return self._get_req_status(headers, body)

    def _get_req_status(self, headers, body):
        """
        Attempts OLI Cloud request with provided headers and body.

        :param headers: request headers
        :param body: request body

        :return boolean: True on success, False on failure
        """

        req_result = requests.post(
            self.credentials["auth_url"], headers=headers, data=body
        )
        if req_result.status_code == 200:
            if self.test is False:
                print(f"Status code is {req_result.status_code}")
            req_result = req_result.json()
            if bool(req_result):
                if "access_token" in req_result:
                    self.jwt_token = req_result["access_token"]
                    if "refresh_token" in req_result:
                        self.refresh_token = req_result["refresh_token"]
                        return True
        if self.test is False:
            raise ConnectionError(
                f" OLI login failed. Status code is {req_result.status_code}."
            )
        else:
            return False

    # TODO: consider merging with _get_req_status
    def request_auto_login(self, req_func=None):
        """
        Gets a new access token if the request returns with an expired token error.

        :param req_func: function to call

        :return boolean: True on success, False on failure
        """

        num_tries = 1

        while num_tries <= 2:
            headers = {"authorization": "Bearer " + self.jwt_token}
            req_result = req_func(headers)
            if req_result.status_code == 200:
                return json.loads(req_result.text)
            elif num_tries == 1 and req_result.status_code == 401:
                req_result = req_result.json()
                if not self.get_refresh_token():
                    if not self.login():
                        break
            else:
                break
            num_tries = num_tries + 1

        if self.test is False:
            raise ConnectionError(
                f" OLI request failed. Status code is {req_result.status_code}."
            )
        else:
            return False
